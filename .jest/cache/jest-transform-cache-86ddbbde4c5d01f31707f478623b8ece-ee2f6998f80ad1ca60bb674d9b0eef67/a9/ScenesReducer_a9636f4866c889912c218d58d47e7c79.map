{"version":3,"sources":["ScenesReducer.tsx"],"names":["SCENE_KEY_PREFIX","delta","one","two","compareKey","areRoutesShallowEqual","scenes","route","scene","descriptors","prevState","prevScenes","freshScenes","staleScenes","key","nextKeys","nextRoutes","nextState","console","descriptor","index","isActive","isStale","prevRoutes","lastScene","nextScenes","mergeScene","nextScene","prevScene","areScenesShallowEqual","activeScenesCount"],"mappings":"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","sourcesContent":["import shallowEqual from '../utils/shallowEqual';\nimport { Scene, Route, NavigationState, SceneDescriptor } from '../types';\n\nconst SCENE_KEY_PREFIX = 'scene_';\n\n/**\n * Helper function to compare route keys (e.g. \"9\", \"11\").\n */\nfunction compareKey(one: string, two: string) {\n  const delta = one.length - two.length;\n  if (delta > 0) {\n    return 1;\n  }\n  if (delta < 0) {\n    return -1;\n  }\n  return one > two ? 1 : -1;\n}\n\n/**\n * Helper function to sort scenes based on their index and view key.\n */\nfunction compareScenes(one: Scene, two: Scene) {\n  if (one.index > two.index) {\n    return 1;\n  }\n  if (one.index < two.index) {\n    return -1;\n  }\n\n  return compareKey(one.key, two.key);\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areScenesShallowEqual(one: Scene, two: Scene) {\n  return (\n    one.key === two.key &&\n    one.index === two.index &&\n    one.isStale === two.isStale &&\n    one.isActive === two.isActive &&\n    areRoutesShallowEqual(one.route, two.route)\n  );\n}\n\n/**\n * Whether two routes are the same.\n */\nfunction areRoutesShallowEqual(one: Route, two: Route) {\n  if (!one || !two) {\n    return one === two;\n  }\n\n  if (one.key !== two.key) {\n    return false;\n  }\n\n  return shallowEqual(one, two);\n}\n\nexport default function ScenesReducer(\n  scenes: Scene[],\n  nextState: NavigationState,\n  prevState: NavigationState | null,\n  descriptors: { [key: string]: SceneDescriptor }\n) {\n  // Always update the descriptors\n  // This is a workaround for https://github.com/react-navigation/react-navigation/issues/4271\n  // It will be resolved in a better way when we re-write Transitioner\n  scenes.forEach(scene => {\n    const { route } = scene;\n    if (descriptors && descriptors[route.key]) {\n      scene.descriptor = descriptors[route.key];\n    }\n  });\n\n  // Bail out early if we didn't update the state\n  if (prevState === nextState) {\n    return scenes;\n  }\n\n  const prevScenes = new Map();\n  const freshScenes = new Map();\n  const staleScenes = new Map();\n\n  // Populate stale scenes from previous scenes marked as stale.\n  scenes.forEach(scene => {\n    const { key } = scene;\n    if (scene.isStale) {\n      staleScenes.set(key, scene);\n    }\n    prevScenes.set(key, scene);\n  });\n\n  const nextKeys = new Set();\n  let nextRoutes = nextState.routes;\n  if (nextRoutes.length > nextState.index + 1) {\n    console.warn(\n      'StackRouter provided invalid state, index should always be the top route'\n    );\n    nextRoutes = nextState.routes.slice(0, nextState.index + 1);\n  }\n\n  nextRoutes.forEach((route, index) => {\n    const key = SCENE_KEY_PREFIX + route.key;\n\n    let descriptor = descriptors && descriptors[route.key];\n\n    const scene: Scene = {\n      index,\n      isActive: false,\n      isStale: false,\n      key,\n      route,\n      descriptor,\n    };\n\n    if (nextKeys.has(key)) {\n      throw new Error(\n        `navigation.state.routes[${index}].key \"${key}\" conflicts with ` +\n          'another route!'\n      );\n    }\n\n    nextKeys.add(key);\n\n    if (staleScenes.has(key)) {\n      // A previously `stale` scene is now part of the nextState, so we\n      // revive it by removing it from the stale scene map.\n      staleScenes.delete(key);\n    }\n    freshScenes.set(key, scene);\n  });\n\n  if (prevState) {\n    let prevRoutes = prevState.routes;\n    if (prevRoutes.length > prevState.index + 1) {\n      console.warn(\n        'StackRouter provided invalid state, index should always be the top route'\n      );\n      prevRoutes = prevRoutes.slice(0, prevState.index + 1);\n    }\n    // Look at the previous routes and classify any removed scenes as `stale`.\n    prevRoutes.forEach((route, index) => {\n      const key = SCENE_KEY_PREFIX + route.key;\n      if (freshScenes.has(key)) {\n        return;\n      }\n      const lastScene = scenes.find(scene => scene.route.key === route.key);\n\n      // We can get into a weird place where we have a queued transition and then clobber\n      // that transition without ever actually rendering the scene, in which case\n      // there is no lastScene. If the descriptor is not available on the lastScene\n      // or the descriptors prop then we just skip adding it to stale scenes and it's\n      // not ever rendered.\n      const descriptor = lastScene\n        ? lastScene.descriptor\n        : descriptors[route.key];\n\n      if (descriptor) {\n        staleScenes.set(key, {\n          index,\n          isActive: false,\n          isStale: true,\n          key,\n          route,\n          descriptor,\n        });\n      }\n    });\n  }\n\n  const nextScenes: Scene[] = [];\n\n  const mergeScene = (nextScene: Scene) => {\n    const { key } = nextScene;\n    const prevScene = prevScenes.has(key) ? prevScenes.get(key) : null;\n    if (prevScene && areScenesShallowEqual(prevScene, nextScene)) {\n      // Reuse `prevScene` as `scene` so view can avoid unnecessary re-render.\n      // This assumes that the scene's navigation state is immutable.\n      nextScenes.push(prevScene);\n    } else {\n      nextScenes.push(nextScene);\n    }\n  };\n\n  staleScenes.forEach(mergeScene);\n  freshScenes.forEach(mergeScene);\n\n  nextScenes.sort(compareScenes);\n\n  let activeScenesCount = 0;\n  nextScenes.forEach((scene, ii) => {\n    const isActive = !scene.isStale && scene.index === nextState.index;\n    if (isActive !== scene.isActive) {\n      nextScenes[ii] = {\n        ...scene,\n        isActive,\n      };\n    }\n    if (isActive) {\n      activeScenesCount++;\n    }\n  });\n\n  if (activeScenesCount !== 1) {\n    throw new Error(\n      `There should always be only one scene active, not ${activeScenesCount}.`\n    );\n  }\n\n  if (nextScenes.length !== scenes.length) {\n    return nextScenes;\n  }\n\n  if (\n    nextScenes.some(\n      (scene, index) => !areScenesShallowEqual(scenes[index], scene)\n    )\n  ) {\n    return nextScenes;\n  }\n\n  // scenes haven't changed.\n  return scenes;\n}\n"]}